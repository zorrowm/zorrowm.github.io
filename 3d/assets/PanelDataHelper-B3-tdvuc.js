import{a as v,bZ as p,bs as b,c1 as m,b_ as g}from"./vendor-CDV5M84i.js";import{w as A}from"./xframelib-exp-CvTEfE5n.js";import{a as G}from"./@vue-exp-YaP0LnBg.js";class D{static async GenerateAngleSector(e,t,i,n,c=!0,l=500,r=65){let s=t,a=n/2;var u=-a+e,o=a+e;if(!c){u=a+e,o=-a+e;let y=180;if(e>0?e=e-180:e<0&&(e=e+180),l!=0){var f=await window.turfAsync.destination(s,l/1e3,180-y,{units:"kilometers"});s=f.geometry.coordinates}}var h=await window.turfAsync.sector(s,i/1e3,u,o,{steps:r,units:"kilometers"});return h}static async BuildSquareGridBySector(e,t,i,n,c=0,l=20){const r=await this.GenerateAngleSector(e,t,i,n);if(c>0){r.geometry.coordinates[0].splice(0,1),r.geometry.coordinates[0].splice(r.geometry.coordinates[0].length-1,1);const u=await this.GenerateAngleSector(e,t,i-c,90);u.geometry.coordinates[0].splice(0,1),u.geometry.coordinates[0].splice(u.geometry.coordinates[0].length-1,1),r.geometry.coordinates[0].push(...u.geometry.coordinates[0].reverse()),r.geometry.coordinates[0].push(r.geometry.coordinates[0][0])}const s=await window.turfAsync.bbox(r);return await window.turfAsync.squareGrid(s,l/1e3,{units:"kilometers",mask:r})}static async GetSquareElevation(e,t,i=100,n=0){const c=e.transform.clone().elevation,l=new Array,r=t.features;for(let a=0;a<r.length-1;a++){const u=r[a],o=await window.turfAsync.center(u)?.geometry.coordinates;if(o){var s=(c+e.queryTerrainElevation({lng:o[0],lat:o[1]})||0)+i;s>=n&&(u.properties={height:s,id:A()},l.push(u))}}return l}static async GetLinePointElevation(e,t,i,n,c){const l=await window.turfAsync.destination(i,n,t,{units:"kilometers"}),r=await window.turfAsync.lineString([i,l.geometry.coordinates]),s=Math.floor(n/c),a=[],u=e.transform.clone().elevation;for(let o=1;o<s;o++){const f=await window.turfAsync.along(r,o*c,{units:"kilometers"}),h=u+e.queryTerrainElevation(f.geometry.coordinates)||0;a.push(h)}return a.push(u+e.queryTerrainElevation(l.geometry.coordinates)||0),a}static async GetLinePointElevation2(e,t,i,n){const c=await window.turfAsync.destination(t,i,e,{units:"kilometers"}),l=await window.turfAsync.lineString([t,c.geometry.coordinates]),r=Math.floor(i/n),s=[];for(let a=1;a<r;a++){const u=await window.turfAsync.along(l,a*n,{units:"kilometers"});s.push(u.geometry.coordinates)}return s}static slopeRule=Math.tan(5*(Math.PI/180));static async GetPlaneDescentRegion(e,t,i=.2,n=.01,c=.0049,l=.05){const r=await this.GetBufferBboxByPoint(t,i);let s={slope:{type:"FeatureCollection",features:[]},warnSlope:{type:"FeatureCollection",features:[]}},a;if(n!=l&&l>n){const o=await window.turfAsync.squareGrid(r,l,{units:"kilometers"});if(o&&o.features&&o.features.length>0){a=o;for(let f=0;f<o.features.length;f++){const h=o.features[f],y=await this.GetBbox(h),w=await this.GetSlopeDirection(e,y,n,c);w?.result.features.length>0&&s.slope.features.push(...w?.result.features),w?.warnResult.features.length>0&&s.warnSlope.features.push(...w?.warnResult.features)}}}else{const o=this.GetSlopeDirection(e,r,n,c);if(!o)return null;s.slope=o.result,s.warnSlope=o.warnResult}const u=turf.bboxPolygon(r);return{...s,bboxPolygon:u,planRegion:a}}static async GetSlopeDirection(e,t,i=.01,n=.0049){const c=await window.turfAsync.squareGrid(t,i,{units:"kilometers"}),l={type:"FeatureCollection",features:[]},r={type:"FeatureCollection",features:[]};if(c.features.length>0){for(let s=0;s<c.features.length;s++){const a=c.features[s],u=await this.GetBbox(a),o=await window.turfAsync.pointGrid(u,n,{units:"kilometers"});if(o.features.length==9){const f=o.features.map(y=>y.geometry.coordinates);await this.getRadianByPointHeight(f,e)?l.features.push(a):r.features.push(a)}}return{result:l,warnResult:r}}return null}static async getRadianByPointHeight(e,t){const i=t.transform.clone().elevation;let n=i+t.queryTerrainElevation(e[2])||0,c=i+t.queryTerrainElevation(e[5])||0,l=i+t.queryTerrainElevation(e[8])||0,r=i+t.queryTerrainElevation(e[1])||0,s=i+t.queryTerrainElevation(e[4])||0,a=i+t.queryTerrainElevation(e[7])||0,u=i+t.queryTerrainElevation(e[0])||0,o=i+t.queryTerrainElevation(e[3])||0,f=i+t.queryTerrainElevation(e[6])||0,h=await window.turfAsync.distance(e[2],e[4],{units:"kilometers"})*1e3;if(this.GetSlope(Math.abs(n-s),h)>this.slopeRule)return!1;let w=await window.turfAsync.distance(e[5],e[4],{units:"kilometers"})*1e3;return!(this.GetSlope(Math.abs(c-s),w)>this.slopeRule||this.GetSlope(Math.abs(l-s),h)>this.slopeRule||this.GetSlope(Math.abs(r-s),w)>this.slopeRule||this.GetSlope(Math.abs(a-s),w)>this.slopeRule||this.GetSlope(Math.abs(u-s),h)>this.slopeRule||this.GetSlope(Math.abs(o-s),w)>this.slopeRule||this.GetSlope(Math.abs(f-s),h)>this.slopeRule)}static GetSlope(e,t){return e==0?0:e/t}static async GetBufferBboxByPoint(e,t=.2){const i=await window.turfAsync.point(e),n=await window.turfAsync.buffer(i,t,{units:"kilometers"});return await this.GetBbox(n)}static async GetBbox(e){return await window.turfAsync.bbox(e)}static async GetLineLength(e){let t;return Array.isArray(e)?t=await window.turfAsync.lineString(e):t=e,await window.turfAsync.length(t,{units:"kilometers"})}static async GetNearestPoint(e,t){return await window.turfAsync.nearestPoint(e,t)}static async PolygonIntersectWarning(e,t){var i=await window.turfAsync.booleanIntersects(e,t);return i}static GetArriveTime(e,t){if(e==0||t==0)return null;let i=t/60,n=e/i,c=Math.floor(n/60),l=n%60,r=Math.floor(l),s=Math.ceil((l-r)*60);return{hour:c,minute:r,second:s}}static GetArriveDateTime(e,t=120){const i=this.GetArriveTime(e,t),n=new Date;return i?.hour&&i.hour>0&&n.setHours(n.getHours()+i.hour),i?.minute&&i.minute>0&&n.setMinutes(n.getMinutes()+i.minute),i?.second&&i.second>0&&n.setSeconds(n.getSeconds()+i.second),n}static async PointDense(e,t){return await window.turfAsync.along(e,t,{units:"kilometers"})}static async GetBearing(e,t){return await window.turfAsync.bearing(e,t)}static async GetBuffer(e,t){return await window.turfAsync.buffer(e,t,{units:"kilometers"})}static async GetLineOffset(e,t){const i={type:"FeatureCollection",features:[]};return i.features.push(await window.turfAsync.lineOffset(e,t,{units:"kilometers"})),i.features.push(await window.turfAsync.lineOffset(e,-t,{units:"kilometers"})),i}static async GetPointDestination(e,t,i){return(await window.turfAsync.destination(e,i,t,{units:"kilometers"})).geometry.coordinates}static async PointToLineDistance(e,t){return await window.turfAsync.pointToLineDistance(e,t,{units:"kilometers"})}static async PointToPointDistance(e,t){return await window.turfAsync.distance(e,t,{units:"kilometers"})*1e3}static async PointIntersectBool(e,t){const i=await window.turfAsync.point(t);return await window.turfAsync.booleanIntersects(e,i)}}const S="YYYY-MM-DD HH:mm:ss";function P(d,e=S){return v.formatDate(d,e)}class _{static _viewer;static panelData=G({travelDistance:0,travelAngle:0,sumDistance:0,height:0,elevation:0,speed:0,arriveTime:"",needTime:0});static terrainProvider;static _terrainLevel;static handlerStatus=!1;static removeCallback;static currentPoint;static init(e=0,t=13){const i=p.getViewer();if(i){this._terrainLevel=t,e!=0&&(this.panelData.sumDistance=e);const n=p.getEntity();if(this.currentPoint=n.position?.getValue(i.clock.currentTime),n)this._viewer=i,this.removeCallback=this._viewer.scene.postRender.addEventListener(this.changeHandler.bind(this)),this.updateArriveTimeBySpeed(),this.handlerStatus=!0;else throw new Error("失败！请先ViewerEntityHelper初始化模型")}else throw new Error("失败！请先ViewerEntityHelper初始化Viewer")}static tempDistance=0;static changeHandler(){if(this.currentPoint){const t=p.getEntity().position?.getValue(this._viewer.clock.currentTime);if(this.currentPoint?.x==t?.x&&this.currentPoint?.y==t?.y&&this.currentPoint?.z==t?.z)return;t&&(this.tempDistance+=Cesium.Cartesian3.distance(this.currentPoint,t),this.panelData.travelDistance=Math.round(this.tempDistance/10)/100,this.panelData.travelAngle=Math.round(Cesium.Math.toDegrees(b.Direction.getHeading(this.currentPoint,t))*100)/100,this.currentPoint=t,this.panelData.speed=m.toHourSpeed(g.currentSpeed),this.getElevationValue())}}static async getElevationValue(){const e=Cesium.Cartographic.fromCartesian(this.currentPoint);this.panelData.height=Math.round(e.height*100)/100}static HandlerStatus(e){this._viewer&&this.handlerStatus!=e&&(e?this.removeCallback=this._viewer.scene.postRender.addEventListener(this.changeHandler.bind(this)):(this._viewer.scene.postRender.removeEventListener(this.removeCallback),this.removeCallback=void 0),this.handlerStatus=e)}static updateArriveTimeBySpeed(){if(this.panelData.sumDistance>0){const e=D.GetArriveDateTime(this.panelData.sumDistance,m.toHourSpeed(g.currentSpeed));e&&(this.panelData.arriveTime=P(e,"HH:mm:ss"))}}}export{_ as P};
