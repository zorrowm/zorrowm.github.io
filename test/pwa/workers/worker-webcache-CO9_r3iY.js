var t,e,i,s,n,h,a,o,r,l,c,u,f,d,p,g,w,v,m,y,b,S,_,E,T,A,O,W,k,M,F,z,x,C,R,L,D,j,G,U,N,P,I,H,B,Y,X,q,V,J,K=Object.defineProperty,Q=t=>{throw TypeError(t)},Z=(t,e,i)=>((t,e,i)=>e in t?K(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i),$=(t,e,i)=>e.has(t)||Q("Cannot "+i),tt=(t,e,i)=>($(t,e,"read from private field"),i?i.call(t):e.get(t)),et=(t,e,i)=>e.has(t)?Q("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),it=(t,e,i,s)=>($(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),st=(t,e,i)=>($(t,e,"access private method"),i),nt=(t,e,i,s)=>({set _(s){it(t,e,s,i)},get _(){return tt(t,e,s)}})
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */;const ht=Symbol("Comlink.proxy"),at=Symbol("Comlink.endpoint"),ot=Symbol("Comlink.releaseProxy"),rt=Symbol("Comlink.finalizer"),lt=Symbol("Comlink.thrown"),ct=t=>"object"==typeof t&&null!==t||"function"==typeof t,ut={canHandle:t=>ct(t)&&t[ht],serialize(t){const{port1:e,port2:i}=new MessageChannel;return dt(t,e),[i,[i]]},deserialize:t=>(t.start(),function(t){const e=new Map;return t.addEventListener("message",(function(t){const{data:i}=t;if(!i||!i.id)return;const s=e.get(i.id);if(s)try{s(i)}finally{e.delete(i.id)}})),yt(t,e,[],void 0)}(t))},ft=new Map([["proxy",ut],["throw",{canHandle:t=>ct(t)&&lt in t,serialize({value:t}){let e;return e=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[e,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function dt(t,e=globalThis,i=["*"]){e.addEventListener("message",(function s(n){if(!n||!n.data)return;if(!function(t,e){for(const i of t){if(e===i||"*"===i)return!0;if(i instanceof RegExp&&i.test(e))return!0}return!1}(i,n.origin))return;const{id:h,type:a,path:o}=Object.assign({path:[]},n.data),r=(n.data.argumentList||[]).map(Et);let l;try{const e=o.slice(0,-1).reduce(((t,e)=>t[e]),t),i=o.reduce(((t,e)=>t[e]),t);switch(a){case"GET":l=i;break;case"SET":e[o.slice(-1)[0]]=Et(n.data.value),l=!0;break;case"APPLY":l=i.apply(e,r);break;case"CONSTRUCT":c=new i(...r),l=Object.assign(c,{[ht]:!0});break;case"ENDPOINT":{const{port1:e,port2:i}=new MessageChannel;dt(t,i),l=function(t,e){return St.set(t,e),t}(e,[e])}break;case"RELEASE":l=void 0;break;default:return}}catch(Yt){l={value:Yt,[lt]:0}}var c;Promise.resolve(l).catch((t=>({value:t,[lt]:0}))).then((i=>{const[n,o]=_t(i);e.postMessage(Object.assign(Object.assign({},n),{id:h}),o),"RELEASE"===a&&(e.removeEventListener("message",s),pt(e),rt in t&&"function"==typeof t[rt]&&t[rt]())})).catch((t=>{const[i,s]=_t({value:new TypeError("Unserializable return value"),[lt]:0});e.postMessage(Object.assign(Object.assign({},i),{id:h}),s)}))})),e.start&&e.start()}function pt(t){"MessagePort"===t.constructor.name&&t.close()}function gt(t){if(t)throw new Error("Proxy has been released and is not useable")}function wt(t){return Tt(t,new Map,{type:"RELEASE"}).then((()=>{pt(t)}))}const vt=new WeakMap,mt="FinalizationRegistry"in globalThis&&new FinalizationRegistry((t=>{const e=(vt.get(t)||0)-1;vt.set(t,e),0===e&&wt(t)}));function yt(t,e,i=[],s=function(){}){let n=!1;const h=new Proxy(s,{get(s,a){if(gt(n),a===ot)return()=>{var i;i=h,mt&&mt.unregister(i),wt(t),e.clear(),n=!0};if("then"===a){if(0===i.length)return{then:()=>h};const s=Tt(t,e,{type:"GET",path:i.map((t=>t.toString()))}).then(Et);return s.then.bind(s)}return yt(t,e,[...i,a])},set(s,h,a){gt(n);const[o,r]=_t(a);return Tt(t,e,{type:"SET",path:[...i,h].map((t=>t.toString())),value:o},r).then(Et)},apply(s,h,a){gt(n);const o=i[i.length-1];if(o===at)return Tt(t,e,{type:"ENDPOINT"}).then(Et);if("bind"===o)return yt(t,e,i.slice(0,-1));const[r,l]=bt(a);return Tt(t,e,{type:"APPLY",path:i.map((t=>t.toString())),argumentList:r},l).then(Et)},construct(s,h){gt(n);const[a,o]=bt(h);return Tt(t,e,{type:"CONSTRUCT",path:i.map((t=>t.toString())),argumentList:a},o).then(Et)}});return function(t,e){const i=(vt.get(e)||0)+1;vt.set(e,i),mt&&mt.register(t,e,t)}(h,t),h}function bt(t){const e=t.map(_t);return[e.map((t=>t[0])),(i=e.map((t=>t[1])),Array.prototype.concat.apply([],i))];var i}const St=new WeakMap;function _t(t){for(const[e,i]of ft)if(i.canHandle(t)){const[s,n]=i.serialize(t);return[{type:"HANDLER",name:e,value:s},n]}return[{type:"RAW",value:t},St.get(t)||[]]}function Et(t){switch(t.type){case"HANDLER":return ft.get(t.name).deserialize(t.value);case"RAW":return t.value}}function Tt(t,e,i,s){return new Promise((n=>{const h=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.set(h,n),t.start&&t.start(),t.postMessage(Object.assign({id:h},i),s)}))}var At,Ot,Wt={exports:{}},kt=Wt.exports={};function Mt(){throw new Error("setTimeout has not been defined")}function Ft(){throw new Error("clearTimeout has not been defined")}function zt(t){if(At===setTimeout)return setTimeout(t,0);if((At===Mt||!At)&&setTimeout)return At=setTimeout,setTimeout(t,0);try{return At(t,0)}catch(e){try{return At.call(null,t,0)}catch(i){return At.call(this,t,0)}}}!function(){try{At="function"==typeof setTimeout?setTimeout:Mt}catch(Yt){At=Mt}try{Ot="function"==typeof clearTimeout?clearTimeout:Ft}catch(Yt){Ot=Ft}}();var xt,Ct=[],Rt=!1,Lt=-1;function Dt(){Rt&&xt&&(Rt=!1,xt.length?Ct=xt.concat(Ct):Lt=-1,Ct.length&&jt())}function jt(){if(!Rt){var t=zt(Dt);Rt=!0;for(var e=Ct.length;e;){for(xt=Ct,Ct=[];++Lt<e;)xt&&xt[Lt].run();Lt=-1,e=Ct.length}xt=null,Rt=!1,function(t){if(Ot===clearTimeout)return clearTimeout(t);if((Ot===Ft||!Ot)&&clearTimeout)return Ot=clearTimeout,clearTimeout(t);try{return Ot(t)}catch(e){try{return Ot.call(null,t)}catch(i){return Ot.call(this,t)}}}(t)}}function Gt(t,e){this.fun=t,this.array=e}function Ut(){}kt.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)e[i-1]=arguments[i];Ct.push(new Gt(t,e)),1!==Ct.length||Rt||zt(jt)},Gt.prototype.run=function(){this.fun.apply(null,this.array)},kt.title="browser",kt.browser=!0,kt.env={},kt.argv=[],kt.version="",kt.versions={},kt.on=Ut,kt.addListener=Ut,kt.once=Ut,kt.off=Ut,kt.removeListener=Ut,kt.removeAllListeners=Ut,kt.emit=Ut,kt.prependListener=Ut,kt.prependOnceListener=Ut,kt.listeners=function(t){return[]},kt.binding=function(t){throw new Error("process.binding is not supported")},kt.cwd=function(){return"/"},kt.chdir=function(t){throw new Error("process.chdir is not supported")},kt.umask=function(){return 0};const Nt=(Yt=Wt.exports)&&Yt.__esModule&&Object.prototype.hasOwnProperty.call(Yt,"default")?Yt.default:Yt,Pt="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,It=new Set,Ht="object"==typeof Nt&&Nt?Nt:{},Bt=(t,e,i,s)=>{"function"==typeof Ht.emitWarning&&Ht.emitWarning(t,e,i,s)};var Yt;let Xt=globalThis.AbortController,qt=globalThis.AbortSignal;if(void 0===Xt){qt=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},Xt=class{constructor(){e()}signal=new qt;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==Ht.env?.LRU_CACHE_IGNORE_AC_WARNING;const e=()=>{t&&(t=!1,Bt("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const Vt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),Jt=t=>Vt(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?Kt:null:null;class Kt extends Array{constructor(t){super(t),this.fill(0)}}const Qt=class e{heap;length;static create(i){const s=Jt(i);if(!s)return[];it(e,t,!0);const n=new e(i,s);return it(e,t,!1),n}constructor(i,s){if(!tt(e,t))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new s(i),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};t=new WeakMap,et(Qt,t,!1);let Zt=Qt;const $t=class t{constructor(i){et(this,F),et(this,s),et(this,n),et(this,h),et(this,a),et(this,o),et(this,r),et(this,l),et(this,c),Z(this,"ttl"),Z(this,"ttlResolution"),Z(this,"ttlAutopurge"),Z(this,"updateAgeOnGet"),Z(this,"updateAgeOnHas"),Z(this,"allowStale"),Z(this,"noDisposeOnSet"),Z(this,"noUpdateTTL"),Z(this,"maxEntrySize"),Z(this,"sizeCalculation"),Z(this,"noDeleteOnFetchRejection"),Z(this,"noDeleteOnStaleGet"),Z(this,"allowStaleOnFetchAbort"),Z(this,"allowStaleOnFetchRejection"),Z(this,"ignoreFetchAbort"),et(this,u),et(this,f),et(this,d),et(this,p),et(this,g),et(this,w),et(this,v),et(this,m),et(this,y),et(this,b),et(this,S),et(this,_),et(this,E),et(this,T),et(this,A),et(this,O),et(this,W),et(this,k),et(this,M),et(this,x,(()=>{})),et(this,C,(()=>{})),et(this,R,(()=>{})),et(this,L,(()=>!1)),et(this,j,(t=>{})),et(this,G,((t,e,i)=>{})),et(this,U,((t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0})),Z(this,e,"LRUCache");const{max:N=0,ttl:P,ttlResolution:I=1,ttlAutopurge:H,updateAgeOnGet:B,updateAgeOnHas:Y,allowStale:X,dispose:q,onInsert:V,disposeAfter:J,noDisposeOnSet:K,noUpdateTTL:Q,maxSize:$=0,maxEntrySize:nt=0,sizeCalculation:ht,fetchMethod:at,memoMethod:ot,noDeleteOnFetchRejection:rt,noDeleteOnStaleGet:lt,allowStaleOnFetchRejection:ct,allowStaleOnFetchAbort:ut,ignoreFetchAbort:ft,perf:dt}=i;if(void 0!==dt&&"function"!=typeof dt?.now)throw new TypeError("perf option must have a now() method if specified");if(it(this,c,dt??Pt),0!==N&&!Vt(N))throw new TypeError("max option must be a nonnegative integer");const pt=N?Jt(N):Array;if(!pt)throw new Error("invalid max value: "+N);if(it(this,s,N),it(this,n,$),this.maxEntrySize=nt||tt(this,n),this.sizeCalculation=ht,this.sizeCalculation){if(!tt(this,n)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==ot&&"function"!=typeof ot)throw new TypeError("memoMethod must be a function if defined");if(it(this,l,ot),void 0!==at&&"function"!=typeof at)throw new TypeError("fetchMethod must be a function if specified");if(it(this,r,at),it(this,W,!!at),it(this,d,new Map),it(this,p,new Array(N).fill(void 0)),it(this,g,new Array(N).fill(void 0)),it(this,w,new pt(N)),it(this,v,new pt(N)),it(this,m,0),it(this,y,0),it(this,b,Zt.create(N)),it(this,u,0),it(this,f,0),"function"==typeof q&&it(this,h,q),"function"==typeof V&&it(this,a,V),"function"==typeof J?(it(this,o,J),it(this,S,[])):(it(this,o,void 0),it(this,S,void 0)),it(this,O,!!tt(this,h)),it(this,M,!!tt(this,a)),it(this,k,!!tt(this,o)),this.noDisposeOnSet=!!K,this.noUpdateTTL=!!Q,this.noDeleteOnFetchRejection=!!rt,this.allowStaleOnFetchRejection=!!ct,this.allowStaleOnFetchAbort=!!ut,this.ignoreFetchAbort=!!ft,0!==this.maxEntrySize){if(0!==tt(this,n)&&!Vt(tt(this,n)))throw new TypeError("maxSize must be a positive integer if specified");if(!Vt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");st(this,F,D).call(this)}if(this.allowStale=!!X,this.noDeleteOnStaleGet=!!lt,this.updateAgeOnGet=!!B,this.updateAgeOnHas=!!Y,this.ttlResolution=Vt(I)||0===I?I:1,this.ttlAutopurge=!!H,this.ttl=P||0,this.ttl){if(!Vt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");st(this,F,z).call(this)}if(0===tt(this,s)&&0===this.ttl&&0===tt(this,n))throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!tt(this,s)&&!tt(this,n)){const e="LRU_CACHE_UNBOUNDED";gt=e,!It.has(gt)&&(It.add(e),Bt("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",e,t))}var gt}get perf(){return tt(this,c)}static unsafeExposeInternals(t){return{starts:tt(t,E),ttls:tt(t,T),autopurgeTimers:tt(t,A),sizes:tt(t,_),keyMap:tt(t,d),keyList:tt(t,p),valList:tt(t,g),next:tt(t,w),prev:tt(t,v),get head(){return tt(t,m)},get tail(){return tt(t,y)},free:tt(t,b),isBackgroundFetch:e=>{var i;return st(i=t,F,Y).call(i,e)},backgroundFetch:(e,i,s,n)=>{var h;return st(h=t,F,B).call(h,e,i,s,n)},moveToTail:e=>{var i;return st(i=t,F,q).call(i,e)},indexes:e=>{var i;return st(i=t,F,N).call(i,e)},rindexes:e=>{var i;return st(i=t,F,P).call(i,e)},isStale:e=>{var i;return tt(i=t,L).call(i,e)}}}get max(){return tt(this,s)}get maxSize(){return tt(this,n)}get calculatedSize(){return tt(this,f)}get size(){return tt(this,u)}get fetchMethod(){return tt(this,r)}get memoMethod(){return tt(this,l)}get dispose(){return tt(this,h)}get onInsert(){return tt(this,a)}get disposeAfter(){return tt(this,o)}getRemainingTTL(t){return tt(this,d).has(t)?1/0:0}*entries(){for(const t of st(this,F,N).call(this))void 0===tt(this,g)[t]||void 0===tt(this,p)[t]||st(this,F,Y).call(this,tt(this,g)[t])||(yield[tt(this,p)[t],tt(this,g)[t]])}*rentries(){for(const t of st(this,F,P).call(this))void 0===tt(this,g)[t]||void 0===tt(this,p)[t]||st(this,F,Y).call(this,tt(this,g)[t])||(yield[tt(this,p)[t],tt(this,g)[t]])}*keys(){for(const t of st(this,F,N).call(this)){const e=tt(this,p)[t];void 0===e||st(this,F,Y).call(this,tt(this,g)[t])||(yield e)}}*rkeys(){for(const t of st(this,F,P).call(this)){const e=tt(this,p)[t];void 0===e||st(this,F,Y).call(this,tt(this,g)[t])||(yield e)}}*values(){for(const t of st(this,F,N).call(this))void 0===tt(this,g)[t]||st(this,F,Y).call(this,tt(this,g)[t])||(yield tt(this,g)[t])}*rvalues(){for(const t of st(this,F,P).call(this))void 0===tt(this,g)[t]||st(this,F,Y).call(this,tt(this,g)[t])||(yield tt(this,g)[t])}[(i=Symbol.iterator,e=Symbol.toStringTag,i)](){return this.entries()}find(t,e={}){for(const i of st(this,F,N).call(this)){const s=tt(this,g)[i],n=st(this,F,Y).call(this,s)?s.__staleWhileFetching:s;if(void 0!==n&&t(n,tt(this,p)[i],this))return this.get(tt(this,p)[i],e)}}forEach(t,e=this){for(const i of st(this,F,N).call(this)){const s=tt(this,g)[i],n=st(this,F,Y).call(this,s)?s.__staleWhileFetching:s;void 0!==n&&t.call(e,n,tt(this,p)[i],this)}}rforEach(t,e=this){for(const i of st(this,F,P).call(this)){const s=tt(this,g)[i],n=st(this,F,Y).call(this,s)?s.__staleWhileFetching:s;void 0!==n&&t.call(e,n,tt(this,p)[i],this)}}purgeStale(){let t=!1;for(const e of st(this,F,P).call(this,{allowStale:!0}))tt(this,L).call(this,e)&&(st(this,F,V).call(this,tt(this,p)[e],"expire"),t=!0);return t}info(t){const e=tt(this,d).get(t);if(void 0===e)return;const i=tt(this,g)[e],s=st(this,F,Y).call(this,i)?i.__staleWhileFetching:i;if(void 0===s)return;const n={value:s};if(tt(this,T)&&tt(this,E)){const t=tt(this,T)[e],i=tt(this,E)[e];if(t&&i){const e=t-(tt(this,c).now()-i);n.ttl=e,n.start=Date.now()}}return tt(this,_)&&(n.size=tt(this,_)[e]),n}dump(){const t=[];for(const e of st(this,F,N).call(this,{allowStale:!0})){const i=tt(this,p)[e],s=tt(this,g)[e],n=st(this,F,Y).call(this,s)?s.__staleWhileFetching:s;if(void 0===n||void 0===i)continue;const h={value:n};if(tt(this,T)&&tt(this,E)){h.ttl=tt(this,T)[e];const t=tt(this,c).now()-tt(this,E)[e];h.start=Math.floor(Date.now()-t)}tt(this,_)&&(h.size=tt(this,_)[e]),t.unshift([i,h])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=tt(this,c).now()-t}this.set(e,i.value,i)}}set(t,e,i={}){var n,r,l,c;if(void 0===e)return this.delete(t),this;const{ttl:f=this.ttl,start:m,noDisposeOnSet:_=this.noDisposeOnSet,sizeCalculation:E=this.sizeCalculation,status:A}=i;let{noUpdateTTL:x=this.noUpdateTTL}=i;const L=tt(this,U).call(this,t,e,i.size||0,E);if(this.maxEntrySize&&L>this.maxEntrySize)return A&&(A.set="miss",A.maxEntrySizeExceeded=!0),st(this,F,V).call(this,t,"set"),this;let D=0===tt(this,u)?void 0:tt(this,d).get(t);if(void 0===D)D=0===tt(this,u)?tt(this,y):0!==tt(this,b).length?tt(this,b).pop():tt(this,u)===tt(this,s)?st(this,F,H).call(this,!1):tt(this,u),tt(this,p)[D]=t,tt(this,g)[D]=e,tt(this,d).set(t,D),tt(this,w)[tt(this,y)]=D,tt(this,v)[D]=tt(this,y),it(this,y,D),nt(this,u)._++,tt(this,G).call(this,D,L,A),A&&(A.set="add"),x=!1,tt(this,M)&&(null==(n=tt(this,a))||n.call(this,e,t,"add"));else{st(this,F,q).call(this,D);const i=tt(this,g)[D];if(e!==i){if(tt(this,W)&&st(this,F,Y).call(this,i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;void 0===e||_||(tt(this,O)&&(null==(r=tt(this,h))||r.call(this,e,t,"set")),tt(this,k)&&tt(this,S)?.push([e,t,"set"]))}else _||(tt(this,O)&&(null==(l=tt(this,h))||l.call(this,i,t,"set")),tt(this,k)&&tt(this,S)?.push([i,t,"set"]));if(tt(this,j).call(this,D),tt(this,G).call(this,D,L,A),tt(this,g)[D]=e,A){A.set="replace";const t=i&&st(this,F,Y).call(this,i)?i.__staleWhileFetching:i;void 0!==t&&(A.oldValue=t)}}else A&&(A.set="update");tt(this,M)&&this.onInsert?.(e,t,e===i?"update":"replace")}if(0===f||tt(this,T)||st(this,F,z).call(this),tt(this,T)&&(x||tt(this,R).call(this,D,f,m),A&&tt(this,C).call(this,A,D)),!_&&tt(this,k)&&tt(this,S)){const t=tt(this,S);let e;for(;e=t?.shift();)null==(c=tt(this,o))||c.call(this,...e)}return this}pop(){var t;try{for(;tt(this,u);){const t=tt(this,g)[tt(this,m)];if(st(this,F,H).call(this,!0),st(this,F,Y).call(this,t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(tt(this,k)&&tt(this,S)){const e=tt(this,S);let i;for(;i=e?.shift();)null==(t=tt(this,o))||t.call(this,...i)}}}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=tt(this,d).get(t);if(void 0!==n){const t=tt(this,g)[n];if(st(this,F,Y).call(this,t)&&void 0===t.__staleWhileFetching)return!1;if(!tt(this,L).call(this,n))return i&&tt(this,x).call(this,n),s&&(s.has="hit",tt(this,C).call(this,s,n)),!0;s&&(s.has="stale",tt(this,C).call(this,s,n))}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=tt(this,d).get(t);if(void 0===s||!i&&tt(this,L).call(this,s))return;const n=tt(this,g)[s];return st(this,F,Y).call(this,n)?n.__staleWhileFetching:n}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:o=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:f=this.ignoreFetchAbort,allowStaleOnFetchAbort:p=this.allowStaleOnFetchAbort,context:w,forceRefresh:v=!1,status:m,signal:y}=e;if(!tt(this,W))return m&&(m.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:m});const b={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:h,noDisposeOnSet:a,size:o,sizeCalculation:r,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:p,ignoreFetchAbort:f,status:m,signal:y};let S=tt(this,d).get(t);if(void 0===S){m&&(m.fetch="miss");const e=st(this,F,B).call(this,t,S,b,w);return e.__returned=e}{const e=tt(this,g)[S];if(st(this,F,Y).call(this,e)){const t=i&&void 0!==e.__staleWhileFetching;return m&&(m.fetch="inflight",t&&(m.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const n=tt(this,L).call(this,S);if(!v&&!n)return m&&(m.fetch="hit"),st(this,F,q).call(this,S),s&&tt(this,x).call(this,S),m&&tt(this,C).call(this,m,S),e;const h=st(this,F,B).call(this,t,S,b,w),a=void 0!==h.__staleWhileFetching&&i;return m&&(m.fetch=n?"stale":"refresh",a&&n&&(m.returnedStale=!0)),a?h.__staleWhileFetching:h.__returned=h}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(void 0===i)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=tt(this,l);if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:n,...h}=e,a=this.get(t,h);if(!n&&void 0!==a)return a;const o=i(t,a,{options:h,context:s});return this.set(t,o,h),o}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:h}=e,a=tt(this,d).get(t);if(void 0!==a){const e=tt(this,g)[a],o=st(this,F,Y).call(this,e);return h&&tt(this,C).call(this,h,a),tt(this,L).call(this,a)?(h&&(h.get="stale"),o?(h&&i&&void 0!==e.__staleWhileFetching&&(h.returnedStale=!0),i?e.__staleWhileFetching:void 0):(n||st(this,F,V).call(this,t,"expire"),h&&i&&(h.returnedStale=!0),i?e:void 0)):(h&&(h.get="hit"),o?e.__staleWhileFetching:(st(this,F,q).call(this,a),s&&tt(this,x).call(this,a),e))}h&&(h.get="miss")}delete(t){return st(this,F,V).call(this,t,"delete")}clear(){return st(this,F,J).call(this,"delete")}};s=new WeakMap,n=new WeakMap,h=new WeakMap,a=new WeakMap,o=new WeakMap,r=new WeakMap,l=new WeakMap,c=new WeakMap,u=new WeakMap,f=new WeakMap,d=new WeakMap,p=new WeakMap,g=new WeakMap,w=new WeakMap,v=new WeakMap,m=new WeakMap,y=new WeakMap,b=new WeakMap,S=new WeakMap,_=new WeakMap,E=new WeakMap,T=new WeakMap,A=new WeakMap,O=new WeakMap,W=new WeakMap,k=new WeakMap,M=new WeakMap,F=new WeakSet,z=function(){const t=new Kt(tt(this,s)),e=new Kt(tt(this,s));it(this,T,t),it(this,E,e);const i=this.ttlAutopurge?new Array(tt(this,s)):void 0;it(this,A,i),it(this,R,((s,n,h=tt(this,c).now())=>{if(e[s]=0!==n?h:0,t[s]=n,i?.[s]&&(clearTimeout(i[s]),i[s]=void 0),0!==n&&i){const t=setTimeout((()=>{tt(this,L).call(this,s)&&st(this,F,V).call(this,tt(this,p)[s],"expire")}),n+1);t.unref&&t.unref(),i[s]=t}})),it(this,x,(i=>{e[i]=0!==t[i]?tt(this,c).now():0})),it(this,C,((i,s)=>{if(t[s]){const a=t[s],o=e[s];if(!a||!o)return;i.ttl=a,i.start=o,i.now=n||h();const r=i.now-o;i.remainingTTL=a-r}}));let n=0;const h=()=>{const t=tt(this,c).now();if(this.ttlResolution>0){n=t;const e=setTimeout((()=>n=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=i=>{const s=tt(this,d).get(i);if(void 0===s)return 0;const a=t[s],o=e[s];return a&&o?a-((n||h())-o):1/0},it(this,L,(i=>{const s=e[i],a=t[i];return!!a&&!!s&&(n||h())-s>a}))},x=new WeakMap,C=new WeakMap,R=new WeakMap,L=new WeakMap,D=function(){const t=new Kt(tt(this,s));it(this,f,0),it(this,_,t),it(this,j,(e=>{it(this,f,tt(this,f)-t[e]),t[e]=0})),it(this,U,((t,e,i,s)=>{if(st(this,F,Y).call(this,e))return 0;if(!Vt(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!Vt(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i})),it(this,G,((e,i,s)=>{if(t[e]=i,tt(this,n)){const i=tt(this,n)-t[e];for(;tt(this,f)>i;)st(this,F,H).call(this,!0)}it(this,f,tt(this,f)+t[e]),s&&(s.entrySize=i,s.totalCalculatedSize=tt(this,f))}))},j=new WeakMap,G=new WeakMap,U=new WeakMap,N=function*({allowStale:t=this.allowStale}={}){if(tt(this,u))for(let e=tt(this,y);st(this,F,I).call(this,e)&&(!t&&tt(this,L).call(this,e)||(yield e),e!==tt(this,m));)e=tt(this,v)[e]},P=function*({allowStale:t=this.allowStale}={}){if(tt(this,u))for(let e=tt(this,m);st(this,F,I).call(this,e)&&(!t&&tt(this,L).call(this,e)||(yield e),e!==tt(this,y));)e=tt(this,w)[e]},I=function(t){return void 0!==t&&tt(this,d).get(tt(this,p)[t])===t},H=function(t){var e;const i=tt(this,m),s=tt(this,p)[i],n=tt(this,g)[i];return tt(this,W)&&st(this,F,Y).call(this,n)?n.__abortController.abort(new Error("evicted")):(tt(this,O)||tt(this,k))&&(tt(this,O)&&(null==(e=tt(this,h))||e.call(this,n,s,"evict")),tt(this,k)&&tt(this,S)?.push([n,s,"evict"])),tt(this,j).call(this,i),tt(this,A)?.[i]&&(clearTimeout(tt(this,A)[i]),tt(this,A)[i]=void 0),t&&(tt(this,p)[i]=void 0,tt(this,g)[i]=void 0,tt(this,b).push(i)),1===tt(this,u)?(it(this,m,it(this,y,0)),tt(this,b).length=0):it(this,m,tt(this,w)[i]),tt(this,d).delete(s),nt(this,u)._--,i},B=function(t,e,i,s){const n=void 0===e?void 0:tt(this,g)[e];if(st(this,F,Y).call(this,n))return n;const h=new Xt,{signal:a}=i;a?.addEventListener("abort",(()=>h.abort(a.reason)),{signal:h.signal});const o={signal:h.signal,options:i,context:s},l=(s,n=!1)=>{const{aborted:a}=h.signal,r=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(a&&!n?(i.status.fetchAborted=!0,i.status.fetchError=h.signal.reason,r&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),a&&!r&&!n)return c(h.signal.reason);const l=u,f=tt(this,g)[e];return(f===u||r&&n&&void 0===f)&&(void 0===s?void 0!==l.__staleWhileFetching?tt(this,g)[e]=l.__staleWhileFetching:st(this,F,V).call(this,t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,o.options))),s},c=s=>{const{aborted:n}=h.signal,a=n&&i.allowStaleOnFetchAbort,o=a||i.allowStaleOnFetchRejection,r=o||i.noDeleteOnFetchRejection,l=u;if(tt(this,g)[e]===u&&(r&&void 0!==l.__staleWhileFetching?a||(tt(this,g)[e]=l.__staleWhileFetching):st(this,F,V).call(this,t,"fetch")),o)return i.status&&void 0!==l.__staleWhileFetching&&(i.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw s};i.status&&(i.status.fetchDispatched=!0);const u=new Promise(((e,s)=>{var a;const c=null==(a=tt(this,r))?void 0:a.call(this,t,n,o);c&&c instanceof Promise&&c.then((t=>e(void 0===t?void 0:t)),s),h.signal.addEventListener("abort",(()=>{i.ignoreFetchAbort&&!i.allowStaleOnFetchAbort||(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>l(t,!0)))}))})).then(l,(t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),c(t)))),f=Object.assign(u,{__abortController:h,__staleWhileFetching:n,__returned:void 0});return void 0===e?(this.set(t,f,{...o.options,status:void 0}),e=tt(this,d).get(t)):tt(this,g)[e]=f,f},Y=function(t){if(!tt(this,W))return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof Xt},X=function(t,e){tt(this,v)[e]=t,tt(this,w)[t]=e},q=function(t){t!==tt(this,y)&&(t===tt(this,m)?it(this,m,tt(this,w)[t]):st(this,F,X).call(this,tt(this,v)[t],tt(this,w)[t]),st(this,F,X).call(this,tt(this,y),t),it(this,y,t))},V=function(t,e){var i,s;let n=!1;if(0!==tt(this,u)){const s=tt(this,d).get(t);if(void 0!==s)if(tt(this,A)?.[s]&&(clearTimeout(tt(this,A)?.[s]),tt(this,A)[s]=void 0),n=!0,1===tt(this,u))st(this,F,J).call(this,e);else{tt(this,j).call(this,s);const n=tt(this,g)[s];if(st(this,F,Y).call(this,n)?n.__abortController.abort(new Error("deleted")):(tt(this,O)||tt(this,k))&&(tt(this,O)&&(null==(i=tt(this,h))||i.call(this,n,t,e)),tt(this,k)&&tt(this,S)?.push([n,t,e])),tt(this,d).delete(t),tt(this,p)[s]=void 0,tt(this,g)[s]=void 0,s===tt(this,y))it(this,y,tt(this,v)[s]);else if(s===tt(this,m))it(this,m,tt(this,w)[s]);else{const t=tt(this,v)[s];tt(this,w)[t]=tt(this,w)[s];const e=tt(this,w)[s];tt(this,v)[e]=tt(this,v)[s]}nt(this,u)._--,tt(this,b).push(s)}}if(tt(this,k)&&tt(this,S)?.length){const t=tt(this,S);let e;for(;e=t?.shift();)null==(s=tt(this,o))||s.call(this,...e)}return n},J=function(t){var e,i;for(const s of st(this,F,P).call(this,{allowStale:!0})){const i=tt(this,g)[s];if(st(this,F,Y).call(this,i))i.__abortController.abort(new Error("deleted"));else{const n=tt(this,p)[s];tt(this,O)&&(null==(e=tt(this,h))||e.call(this,i,n,t)),tt(this,k)&&tt(this,S)?.push([i,n,t])}}if(tt(this,d).clear(),tt(this,g).fill(void 0),tt(this,p).fill(void 0),tt(this,T)&&tt(this,E)){tt(this,T).fill(0),tt(this,E).fill(0);for(const t of tt(this,A)??[])void 0!==t&&clearTimeout(t);tt(this,A)?.fill(void 0)}if(tt(this,_)&&tt(this,_).fill(0),it(this,m,0),it(this,y,0),tt(this,b).length=0,it(this,f,0),it(this,u,0),tt(this,k)&&tt(this,S)){const t=tt(this,S);let e;for(;e=t?.shift();)null==(i=tt(this,o))||i.call(this,...e)}};let te=$t;const ee=class{static createCache(t=this.defaultOptions){return new te(t)}static set(t,e,i=this.cache){let s=i;s||(s=this.cache),s.set(t,e)}static get(t,e=this.cache){let i=e;return i||(i=this.cache),i.get(t)}static remove(t,e=this.cache){let i=e;return i||(i=this.cache),i.del(t)}static has(t,e=this.cache){let i=e;return i||(i=this.cache),i.has(t)}static count(t=this.cache){let e=t;return e||(e=this.cache),e.size}static maxSize(t=this.cache){let e=t;return e||(e=this.cache),e.max}static peek(t,e=this.cache){let i=e;return i||(i=this.cache),i.peek(t)}static keys(t=this.cache){let e=t;return e||(e=this.cache),e.keys()}static clear(t=this.cache){let e=t;e||(e=this.cache),e.clear()}};Z(ee,"defaultOptions",{max:1e3,maxAge:18e5}),Z(ee,"cache",new te(ee.defaultOptions));let ie=ee;const se=new Map;async function ne(t,e=void 0){const i={max:1e3,maxAage:18e5};let s=i;e&&(s={...i,...e});const n=ie.createCache(s);return se.set(t,n),n}async function he(t=""){let e;return e=se.has(t)?se.get(t):await ne(t),e}dt(Object.freeze({__proto__:null,clear:async function(t=""){const e=await he(t);return e&&ie.clear(e),!1},count:async function(t=""){const e=await he(t);return e?ie.count(e):0},createCache:ne,get:async function(t,e=""){const i=await he(e);if(i){return ie.get(t,i)}},getCacheObject:he,has:async function(t,e=""){const i=await he(e);return!!i&&ie.has(t,i)},keys:async function(t=""){const e=await he(t);if(e)return ie.keys(e)},maxSize:async function(t=""){const e=await he(t);return e?ie.maxSize(e):0},peek:async function(t,e=""){const i=await he(e);return!!i&&ie.peek(t,i)},remove:async function(t,e=""){const i=await he(e);if(i)return ie.remove(t,i)},set:async function(t,e,i=""){const s=await he(i);return!!s&&(ie.set(t,e,s),!0)}}));
