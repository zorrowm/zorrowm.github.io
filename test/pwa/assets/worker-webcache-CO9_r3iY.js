/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const t=Symbol("Comlink.proxy"),e=Symbol("Comlink.endpoint"),i=Symbol("Comlink.releaseProxy"),s=Symbol("Comlink.finalizer"),n=Symbol("Comlink.thrown"),o=t=>"object"==typeof t&&null!==t||"function"==typeof t,r={canHandle:e=>o(e)&&e[t],serialize(t){const{port1:e,port2:i}=new MessageChannel;return a(t,e),[i,[i]]},deserialize:t=>(t.start(),function(t){const e=new Map;return t.addEventListener("message",(function(t){const{data:i}=t;if(!i||!i.id)return;const s=e.get(i.id);if(s)try{s(i)}finally{e.delete(i.id)}})),p(t,e,[],void 0)}(t))},h=new Map([["proxy",r],["throw",{canHandle:t=>o(t)&&n in t,serialize({value:t}){let e;return e=t instanceof Error?{isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:{isError:!1,value:t},[e,[]]},deserialize(t){if(t.isError)throw Object.assign(new Error(t.value.message),t.value);throw t.value}}]]);function a(e,i=globalThis,o=["*"]){i.addEventListener("message",(function r(h){if(!h||!h.data)return;if(!function(t,e){for(const i of t){if(e===i||"*"===i)return!0;if(i instanceof RegExp&&i.test(e))return!0}return!1}(o,h.origin))return void console.warn(`Invalid origin '${h.origin}' for comlink proxy`);const{id:c,type:u,path:f}=Object.assign({path:[]},h.data),d=(h.data.argumentList||[]).map(v);let p;try{const i=f.slice(0,-1).reduce(((t,e)=>t[e]),e),s=f.reduce(((t,e)=>t[e]),e);switch(u){case"GET":p=s;break;case"SET":i[f.slice(-1)[0]]=v(h.data.value),p=!0;break;case"APPLY":p=s.apply(i,d);break;case"CONSTRUCT":p=function(e){return Object.assign(e,{[t]:!0})}(new s(...d));break;case"ENDPOINT":{const{port1:t,port2:i}=new MessageChannel;a(e,i),p=function(t,e){return w.set(t,e),t}(t,[t])}break;case"RELEASE":p=void 0;break;default:return}}catch(t){p={value:t,[n]:0}}Promise.resolve(p).catch((t=>({value:t,[n]:0}))).then((t=>{const[n,o]=m(t);i.postMessage(Object.assign(Object.assign({},n),{id:c}),o),"RELEASE"===u&&(i.removeEventListener("message",r),l(i),s in e&&"function"==typeof e[s]&&e[s]())})).catch((t=>{const[e,s]=m({value:new TypeError("Unserializable return value"),[n]:0});i.postMessage(Object.assign(Object.assign({},e),{id:c}),s)}))})),i.start&&i.start()}function l(t){(function(t){return"MessagePort"===t.constructor.name})(t)&&t.close()}function c(t){if(t)throw new Error("Proxy has been released and is not useable")}function u(t){return y(t,new Map,{type:"RELEASE"}).then((()=>{l(t)}))}const f=new WeakMap,d="FinalizationRegistry"in globalThis&&new FinalizationRegistry((t=>{const e=(f.get(t)||0)-1;f.set(t,e),0===e&&u(t)}));function p(t,s,n=[],o=function(){}){let r=!1;const h=new Proxy(o,{get(e,o){if(c(r),o===i)return()=>{!function(t){d&&d.unregister(t)}(h),u(t),s.clear(),r=!0};if("then"===o){if(0===n.length)return{then:()=>h};const e=y(t,s,{type:"GET",path:n.map((t=>t.toString()))}).then(v);return e.then.bind(e)}return p(t,s,[...n,o])},set(e,i,o){c(r);const[h,a]=m(o);return y(t,s,{type:"SET",path:[...n,i].map((t=>t.toString())),value:h},a).then(v)},apply(i,o,h){c(r);const a=n[n.length-1];if(a===e)return y(t,s,{type:"ENDPOINT"}).then(v);if("bind"===a)return p(t,s,n.slice(0,-1));const[l,u]=g(h);return y(t,s,{type:"APPLY",path:n.map((t=>t.toString())),argumentList:l},u).then(v)},construct(e,i){c(r);const[o,h]=g(i);return y(t,s,{type:"CONSTRUCT",path:n.map((t=>t.toString())),argumentList:o},h).then(v)}});return function(t,e){const i=(f.get(e)||0)+1;f.set(e,i),d&&d.register(t,e,t)}(h,t),h}function g(t){const e=t.map(m);return[e.map((t=>t[0])),(i=e.map((t=>t[1])),Array.prototype.concat.apply([],i))];var i}const w=new WeakMap;function m(t){for(const[e,i]of h)if(i.canHandle(t)){const[s,n]=i.serialize(t);return[{type:"HANDLER",name:e,value:s},n]}return[{type:"RAW",value:t},w.get(t)||[]]}function v(t){switch(t.type){case"HANDLER":return h.get(t.name).deserialize(t.value);case"RAW":return t.value}}function y(t,e,i,s){return new Promise((n=>{const o=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.set(o,n),t.start&&t.start(),t.postMessage(Object.assign({id:o},i),s)}))}var S,b,_={exports:{}},A=_.exports={};function E(){throw new Error("setTimeout has not been defined")}function T(){throw new Error("clearTimeout has not been defined")}function O(t){if(S===setTimeout)return setTimeout(t,0);if((S===E||!S)&&setTimeout)return S=setTimeout,setTimeout(t,0);try{return S(t,0)}catch(e){try{return S.call(null,t,0)}catch(e){return S.call(this,t,0)}}}!function(){try{S="function"==typeof setTimeout?setTimeout:E}catch(t){S=E}try{b="function"==typeof clearTimeout?clearTimeout:T}catch(t){b=T}}();var F,z=[],x=!1,C=-1;function R(){x&&F&&(x=!1,F.length?z=F.concat(z):C=-1,z.length&&L())}function L(){if(!x){var t=O(R);x=!0;for(var e=z.length;e;){for(F=z,z=[];++C<e;)F&&F[C].run();C=-1,e=z.length}F=null,x=!1,function(t){if(b===clearTimeout)return clearTimeout(t);if((b===T||!b)&&clearTimeout)return b=clearTimeout,clearTimeout(t);try{return b(t)}catch(e){try{return b.call(null,t)}catch(e){return b.call(this,t)}}}(t)}}function D(t,e){this.fun=t,this.array=e}function W(){}A.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)e[i-1]=arguments[i];z.push(new D(t,e)),1!==z.length||x||O(L)},D.prototype.run=function(){this.fun.apply(null,this.array)},A.title="browser",A.browser=!0,A.env={},A.argv=[],A.version="",A.versions={},A.on=W,A.addListener=W,A.once=W,A.off=W,A.removeListener=W,A.removeAllListeners=W,A.emit=W,A.prependListener=W,A.prependOnceListener=W,A.listeners=function(t){return[]},A.binding=function(t){throw new Error("process.binding is not supported")},A.cwd=function(){return"/"},A.chdir=function(t){throw new Error("process.chdir is not supported")},A.umask=function(){return 0};const k=function(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}(_.exports),M="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,j=new Set,G="object"==typeof k&&k?k:{},N=(t,e,i,s)=>{"function"==typeof G.emitWarning?G.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)};let U=globalThis.AbortController,P=globalThis.AbortSignal;if(void 0===U){P=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},U=class{constructor(){e()}signal=new P;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==G.env?.LRU_CACHE_IGNORE_AC_WARNING;const e=()=>{t&&(t=!1,N("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const I=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),H=t=>I(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?B:null:null;class B extends Array{constructor(t){super(t),this.fill(0)}}class q{heap;length;static#t=!1;static create(t){const e=H(t);if(!e)return[];q.#t=!0;const i=new q(t,e);return q.#t=!1,i}constructor(t,e){if(!q.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class V{#e;#i;#s;#n;#o;#r;#h;#a;get perf(){return this.#a}ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#l;#c;#u;#f;#d;#p;#g;#w;#m;#v;#y;#S;#b;#_;#A;#E;#T;#O;#F;static unsafeExposeInternals(t){return{starts:t.#b,ttls:t.#_,autopurgeTimers:t.#A,sizes:t.#S,keyMap:t.#u,keyList:t.#f,valList:t.#d,next:t.#p,prev:t.#g,get head(){return t.#w},get tail(){return t.#m},free:t.#v,isBackgroundFetch:e=>t.#z(e),backgroundFetch:(e,i,s,n)=>t.#x(e,i,s,n),moveToTail:e=>t.#C(e),indexes:e=>t.#R(e),rindexes:e=>t.#L(e),isStale:e=>t.#D(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#c}get size(){return this.#l}get fetchMethod(){return this.#r}get memoMethod(){return this.#h}get dispose(){return this.#s}get onInsert(){return this.#n}get disposeAfter(){return this.#o}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:n,updateAgeOnGet:o,updateAgeOnHas:r,allowStale:h,dispose:a,onInsert:l,disposeAfter:c,noDisposeOnSet:u,noUpdateTTL:f,maxSize:d=0,maxEntrySize:p=0,sizeCalculation:g,fetchMethod:w,memoMethod:m,noDeleteOnFetchRejection:v,noDeleteOnStaleGet:y,allowStaleOnFetchRejection:S,allowStaleOnFetchAbort:b,ignoreFetchAbort:_,perf:A}=t;if(void 0!==A&&"function"!=typeof A?.now)throw new TypeError("perf option must have a now() method if specified");if(this.#a=A??M,0!==e&&!I(e))throw new TypeError("max option must be a nonnegative integer");const E=e?H(e):Array;if(!E)throw new Error("invalid max value: "+e);if(this.#e=e,this.#i=d,this.maxEntrySize=p||this.#i,this.sizeCalculation=g,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==m&&"function"!=typeof m)throw new TypeError("memoMethod must be a function if defined");if(this.#h=m,void 0!==w&&"function"!=typeof w)throw new TypeError("fetchMethod must be a function if specified");if(this.#r=w,this.#T=!!w,this.#u=new Map,this.#f=new Array(e).fill(void 0),this.#d=new Array(e).fill(void 0),this.#p=new E(e),this.#g=new E(e),this.#w=0,this.#m=0,this.#v=q.create(e),this.#l=0,this.#c=0,"function"==typeof a&&(this.#s=a),"function"==typeof l&&(this.#n=l),"function"==typeof c?(this.#o=c,this.#y=[]):(this.#o=void 0,this.#y=void 0),this.#E=!!this.#s,this.#F=!!this.#n,this.#O=!!this.#o,this.noDisposeOnSet=!!u,this.noUpdateTTL=!!f,this.noDeleteOnFetchRejection=!!v,this.allowStaleOnFetchRejection=!!S,this.allowStaleOnFetchAbort=!!b,this.ignoreFetchAbort=!!_,0!==this.maxEntrySize){if(0!==this.#i&&!I(this.#i))throw new TypeError("maxSize must be a positive integer if specified");if(!I(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#W()}if(this.allowStale=!!h,this.noDeleteOnStaleGet=!!y,this.updateAgeOnGet=!!o,this.updateAgeOnHas=!!r,this.ttlResolution=I(s)||0===s?s:1,this.ttlAutopurge=!!n,this.ttl=i||0,this.ttl){if(!I(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#k()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";(t=>!j.has(t))(t)&&(j.add(t),N("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,V))}}getRemainingTTL(t){return this.#u.has(t)?1/0:0}#k(){const t=new B(this.#e),e=new B(this.#e);this.#_=t,this.#b=e;const i=this.ttlAutopurge?new Array(this.#e):void 0;this.#A=i,this.#M=(s,n,o=this.#a.now())=>{if(e[s]=0!==n?o:0,t[s]=n,i?.[s]&&(clearTimeout(i[s]),i[s]=void 0),0!==n&&i){const t=setTimeout((()=>{this.#D(s)&&this.#j(this.#f[s],"expire")}),n+1);t.unref&&t.unref(),i[s]=t}},this.#G=i=>{e[i]=0!==t[i]?this.#a.now():0},this.#N=(i,o)=>{if(t[o]){const r=t[o],h=e[o];if(!r||!h)return;i.ttl=r,i.start=h,i.now=s||n();const a=i.now-h;i.remainingTTL=r-a}};let s=0;const n=()=>{const t=this.#a.now();if(this.ttlResolution>0){s=t;const e=setTimeout((()=>s=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=i=>{const o=this.#u.get(i);if(void 0===o)return 0;const r=t[o],h=e[o];return r&&h?r-((s||n())-h):1/0},this.#D=i=>{const o=e[i],r=t[i];return!!r&&!!o&&(s||n())-o>r}}#G=()=>{};#N=()=>{};#M=()=>{};#D=()=>!1;#W(){const t=new B(this.#e);this.#c=0,this.#S=t,this.#U=e=>{this.#c-=t[e],t[e]=0},this.#P=(t,e,i,s)=>{if(this.#z(e))return 0;if(!I(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!I(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i},this.#I=(e,i,s)=>{if(t[e]=i,this.#i){const i=this.#i-t[e];for(;this.#c>i;)this.#H(!0)}this.#c+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#c)}}#U=t=>{};#I=(t,e,i)=>{};#P=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#R({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#m;this.#B(e)&&(!t&&this.#D(e)||(yield e),e!==this.#w);)e=this.#g[e]}*#L({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#w;this.#B(e)&&(!t&&this.#D(e)||(yield e),e!==this.#m);)e=this.#p[e]}#B(t){return void 0!==t&&this.#u.get(this.#f[t])===t}*entries(){for(const t of this.#R())void 0===this.#d[t]||void 0===this.#f[t]||this.#z(this.#d[t])||(yield[this.#f[t],this.#d[t]])}*rentries(){for(const t of this.#L())void 0===this.#d[t]||void 0===this.#f[t]||this.#z(this.#d[t])||(yield[this.#f[t],this.#d[t]])}*keys(){for(const t of this.#R()){const e=this.#f[t];void 0===e||this.#z(this.#d[t])||(yield e)}}*rkeys(){for(const t of this.#L()){const e=this.#f[t];void 0===e||this.#z(this.#d[t])||(yield e)}}*values(){for(const t of this.#R())void 0===this.#d[t]||this.#z(this.#d[t])||(yield this.#d[t])}*rvalues(){for(const t of this.#L())void 0===this.#d[t]||this.#z(this.#d[t])||(yield this.#d[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#R()){const s=this.#d[i],n=this.#z(s)?s.__staleWhileFetching:s;if(void 0!==n&&t(n,this.#f[i],this))return this.get(this.#f[i],e)}}forEach(t,e=this){for(const i of this.#R()){const s=this.#d[i],n=this.#z(s)?s.__staleWhileFetching:s;void 0!==n&&t.call(e,n,this.#f[i],this)}}rforEach(t,e=this){for(const i of this.#L()){const s=this.#d[i],n=this.#z(s)?s.__staleWhileFetching:s;void 0!==n&&t.call(e,n,this.#f[i],this)}}purgeStale(){let t=!1;for(const e of this.#L({allowStale:!0}))this.#D(e)&&(this.#j(this.#f[e],"expire"),t=!0);return t}info(t){const e=this.#u.get(t);if(void 0===e)return;const i=this.#d[e],s=this.#z(i)?i.__staleWhileFetching:i;if(void 0===s)return;const n={value:s};if(this.#_&&this.#b){const t=this.#_[e],i=this.#b[e];if(t&&i){const e=t-(this.#a.now()-i);n.ttl=e,n.start=Date.now()}}return this.#S&&(n.size=this.#S[e]),n}dump(){const t=[];for(const e of this.#R({allowStale:!0})){const i=this.#f[e],s=this.#d[e],n=this.#z(s)?s.__staleWhileFetching:s;if(void 0===n||void 0===i)continue;const o={value:n};if(this.#_&&this.#b){o.ttl=this.#_[e];const t=this.#a.now()-this.#b[e];o.start=Math.floor(Date.now()-t)}this.#S&&(o.size=this.#S[e]),t.unshift([i,o])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=this.#a.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;const{ttl:s=this.ttl,start:n,noDisposeOnSet:o=this.noDisposeOnSet,sizeCalculation:r=this.sizeCalculation,status:h}=i;let{noUpdateTTL:a=this.noUpdateTTL}=i;const l=this.#P(t,e,i.size||0,r);if(this.maxEntrySize&&l>this.maxEntrySize)return h&&(h.set="miss",h.maxEntrySizeExceeded=!0),this.#j(t,"set"),this;let c=0===this.#l?void 0:this.#u.get(t);if(void 0===c)c=0===this.#l?this.#m:0!==this.#v.length?this.#v.pop():this.#l===this.#e?this.#H(!1):this.#l,this.#f[c]=t,this.#d[c]=e,this.#u.set(t,c),this.#p[this.#m]=c,this.#g[c]=this.#m,this.#m=c,this.#l++,this.#I(c,l,h),h&&(h.set="add"),a=!1,this.#F&&this.#n?.(e,t,"add");else{this.#C(c);const i=this.#d[c];if(e!==i){if(this.#T&&this.#z(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;void 0===e||o||(this.#E&&this.#s?.(e,t,"set"),this.#O&&this.#y?.push([e,t,"set"]))}else o||(this.#E&&this.#s?.(i,t,"set"),this.#O&&this.#y?.push([i,t,"set"]));if(this.#U(c),this.#I(c,l,h),this.#d[c]=e,h){h.set="replace";const t=i&&this.#z(i)?i.__staleWhileFetching:i;void 0!==t&&(h.oldValue=t)}}else h&&(h.set="update");this.#F&&this.onInsert?.(e,t,e===i?"update":"replace")}if(0===s||this.#_||this.#k(),this.#_&&(a||this.#M(c,s,n),h&&this.#N(h,c)),!o&&this.#O&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#o?.(...e)}return this}pop(){try{for(;this.#l;){const t=this.#d[this.#w];if(this.#H(!0),this.#z(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#O&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#o?.(...e)}}}#H(t){const e=this.#w,i=this.#f[e],s=this.#d[e];return this.#T&&this.#z(s)?s.__abortController.abort(new Error("evicted")):(this.#E||this.#O)&&(this.#E&&this.#s?.(s,i,"evict"),this.#O&&this.#y?.push([s,i,"evict"])),this.#U(e),this.#A?.[e]&&(clearTimeout(this.#A[e]),this.#A[e]=void 0),t&&(this.#f[e]=void 0,this.#d[e]=void 0,this.#v.push(e)),1===this.#l?(this.#w=this.#m=0,this.#v.length=0):this.#w=this.#p[e],this.#u.delete(i),this.#l--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=this.#u.get(t);if(void 0!==n){const t=this.#d[n];if(this.#z(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#D(n))return i&&this.#G(n),s&&(s.has="hit",this.#N(s,n)),!0;s&&(s.has="stale",this.#N(s,n))}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#u.get(t);if(void 0===s||!i&&this.#D(s))return;const n=this.#d[s];return this.#z(n)?n.__staleWhileFetching:n}#x(t,e,i,s){const n=void 0===e?void 0:this.#d[e];if(this.#z(n))return n;const o=new U,{signal:r}=i;r?.addEventListener("abort",(()=>o.abort(r.reason)),{signal:o.signal});const h={signal:o.signal,options:i,context:s},a=(s,n=!1)=>{const{aborted:r}=o.signal,a=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(r&&!n?(i.status.fetchAborted=!0,i.status.fetchError=o.signal.reason,a&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),r&&!a&&!n)return l(o.signal.reason);const u=c,f=this.#d[e];return(f===c||a&&n&&void 0===f)&&(void 0===s?void 0!==u.__staleWhileFetching?this.#d[e]=u.__staleWhileFetching:this.#j(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,h.options))),s},l=s=>{const{aborted:n}=o.signal,r=n&&i.allowStaleOnFetchAbort,h=r||i.allowStaleOnFetchRejection,a=h||i.noDeleteOnFetchRejection,l=c;if(this.#d[e]===c&&(a&&void 0!==l.__staleWhileFetching?r||(this.#d[e]=l.__staleWhileFetching):this.#j(t,"fetch")),h)return i.status&&void 0!==l.__staleWhileFetching&&(i.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw s};i.status&&(i.status.fetchDispatched=!0);const c=new Promise(((e,s)=>{const r=this.#r?.(t,n,h);r&&r instanceof Promise&&r.then((t=>e(void 0===t?void 0:t)),s),o.signal.addEventListener("abort",(()=>{i.ignoreFetchAbort&&!i.allowStaleOnFetchAbort||(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>a(t,!0)))}))})).then(a,(t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),l(t)))),u=Object.assign(c,{__abortController:o,__staleWhileFetching:n,__returned:void 0});return void 0===e?(this.set(t,u,{...h.options,status:void 0}),e=this.#u.get(t)):this.#d[e]=u,u}#z(t){if(!this.#T)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof U}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:o=this.ttl,noDisposeOnSet:r=this.noDisposeOnSet,size:h=0,sizeCalculation:a=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:f=this.ignoreFetchAbort,allowStaleOnFetchAbort:d=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:w,signal:m}=e;if(!this.#T)return w&&(w.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:w});const v={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:o,noDisposeOnSet:r,size:h,sizeCalculation:a,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:d,ignoreFetchAbort:f,status:w,signal:m};let y=this.#u.get(t);if(void 0===y){w&&(w.fetch="miss");const e=this.#x(t,y,v,p);return e.__returned=e}{const e=this.#d[y];if(this.#z(e)){const t=i&&void 0!==e.__staleWhileFetching;return w&&(w.fetch="inflight",t&&(w.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const n=this.#D(y);if(!g&&!n)return w&&(w.fetch="hit"),this.#C(y),s&&this.#G(y),w&&this.#N(w,y),e;const o=this.#x(t,y,v,p),r=void 0!==o.__staleWhileFetching&&i;return w&&(w.fetch=n?"stale":"refresh",r&&n&&(w.returnedStale=!0)),r?o.__staleWhileFetching:o.__returned=o}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(void 0===i)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#h;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:n,...o}=e,r=this.get(t,o);if(!n&&void 0!==r)return r;const h=i(t,r,{options:o,context:s});return this.set(t,h,o),h}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:o}=e,r=this.#u.get(t);if(void 0!==r){const e=this.#d[r],h=this.#z(e);return o&&this.#N(o,r),this.#D(r)?(o&&(o.get="stale"),h?(o&&i&&void 0!==e.__staleWhileFetching&&(o.returnedStale=!0),i?e.__staleWhileFetching:void 0):(n||this.#j(t,"expire"),o&&i&&(o.returnedStale=!0),i?e:void 0)):(o&&(o.get="hit"),h?e.__staleWhileFetching:(this.#C(r),s&&this.#G(r),e))}o&&(o.get="miss")}#q(t,e){this.#g[e]=t,this.#p[t]=e}#C(t){t!==this.#m&&(t===this.#w?this.#w=this.#p[t]:this.#q(this.#g[t],this.#p[t]),this.#q(this.#m,t),this.#m=t)}delete(t){return this.#j(t,"delete")}#j(t,e){let i=!1;if(0!==this.#l){const s=this.#u.get(t);if(void 0!==s)if(this.#A?.[s]&&(clearTimeout(this.#A?.[s]),this.#A[s]=void 0),i=!0,1===this.#l)this.#V(e);else{this.#U(s);const i=this.#d[s];if(this.#z(i)?i.__abortController.abort(new Error("deleted")):(this.#E||this.#O)&&(this.#E&&this.#s?.(i,t,e),this.#O&&this.#y?.push([i,t,e])),this.#u.delete(t),this.#f[s]=void 0,this.#d[s]=void 0,s===this.#m)this.#m=this.#g[s];else if(s===this.#w)this.#w=this.#p[s];else{const t=this.#g[s];this.#p[t]=this.#p[s];const e=this.#p[s];this.#g[e]=this.#g[s]}this.#l--,this.#v.push(s)}}if(this.#O&&this.#y?.length){const t=this.#y;let e;for(;e=t?.shift();)this.#o?.(...e)}return i}clear(){return this.#V("delete")}#V(t){for(const e of this.#L({allowStale:!0})){const i=this.#d[e];if(this.#z(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#f[e];this.#E&&this.#s?.(i,s,t),this.#O&&this.#y?.push([i,s,t])}}if(this.#u.clear(),this.#d.fill(void 0),this.#f.fill(void 0),this.#_&&this.#b){this.#_.fill(0),this.#b.fill(0);for(const t of this.#A??[])void 0!==t&&clearTimeout(t);this.#A?.fill(void 0)}if(this.#S&&this.#S.fill(0),this.#w=0,this.#m=0,this.#v.length=0,this.#c=0,this.#l=0,this.#O&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#o?.(...e)}}}class ${static defaultOptions={max:1e3,maxAge:18e5};static cache=new V(this.defaultOptions);static createCache(t=this.defaultOptions){return new V(t)}static set(t,e,i=this.cache){let s=i;s||(s=this.cache),s.set(t,e)}static get(t,e=this.cache){let i=e;return i||(i=this.cache),i.get(t)}static remove(t,e=this.cache){let i=e;return i||(i=this.cache),i.del(t)}static has(t,e=this.cache){let i=e;return i||(i=this.cache),i.has(t)}static count(t=this.cache){let e=t;return e||(e=this.cache),e.size}static maxSize(t=this.cache){let e=t;return e||(e=this.cache),e.max}static peek(t,e=this.cache){let i=e;return i||(i=this.cache),i.peek(t)}static keys(t=this.cache){let e=t;return e||(e=this.cache),e.keys()}static clear(t=this.cache){let e=t;e||(e=this.cache),e.clear()}}const Y=new Map;async function X(t,e=void 0){const i={max:1e3,maxAage:18e5};let s=i;e&&(s={...i,...e});const n=$.createCache(s);return Y.set(t,n),n}async function J(t=""){let e;return e=Y.has(t)?Y.get(t):await X(t),e}a(Object.freeze({__proto__:null,clear:async function(t=""){const e=await J(t);return e&&$.clear(e),!1},count:async function(t=""){const e=await J(t);return e?$.count(e):0},createCache:X,get:async function(t,e=""){const i=await J(e);if(i){const e=$.get(t,i);return console.log("666000",t,e),e}},getCacheObject:J,has:async function(t,e=""){const i=await J(e);return!!i&&$.has(t,i)},keys:async function(t=""){const e=await J(t);if(e)return $.keys(e)},maxSize:async function(t=""){const e=await J(t);return e?$.maxSize(e):0},peek:async function(t,e=""){const i=await J(e);return!!i&&$.peek(t,i)},remove:async function(t,e=""){const i=await J(e);if(i)return $.remove(t,i)},set:async function(t,e,i=""){const s=await J(i);return!!s&&($.set(t,e,s),!0)}}));
