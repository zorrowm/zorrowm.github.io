import{V as t,X as e,E as n,Y as s,Z as o,n as a,U as c,K as r,w as i,C as u,_ as f,r as l,$ as p,a0 as h,J as d,a1 as y}from"./@vue-exp-CvWX4Ub_.js";let b;const v=t=>b=t,_=Symbol();function j(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}var S,$;function O(){const t=e(!0),n=t.run((()=>l({})));let s=[],o=[];const a=r({install(t){v(a),a._a=t,t.provide(_,a),t.config.globalProperties.$pinia=a,o.forEach((t=>s.push(t))),o=[]},use(t){return this._a?s.push(t):o.push(t),this},_p:s,_a:null,_e:t,_s:new Map,state:n});return a}($=S||(S={})).direct="direct",$.patchObject="patch object",$.patchFunction="patch function";const m=()=>{};function g(t,e,n,s=m){t.add(e);const o=()=>{t.delete(e)&&s()};return!n&&p()&&h(o),o}function w(t,...e){t.forEach((t=>{t(...e)}))}const E=t=>t(),P=Symbol(),x=Symbol();function I(t,e){t instanceof Map&&e instanceof Map?e.forEach(((e,n)=>t.set(n,e))):t instanceof Set&&e instanceof Set&&e.forEach(t.add,t);for(const o in e){if(!e.hasOwnProperty(o))continue;const a=e[o],c=t[o];j(c)&&j(a)&&t.hasOwnProperty(o)&&!n(a)&&!s(a)?t[o]=I(c,a):t[o]=a}return t}const M=Symbol();const{assign:A}=Object;function C(c,r,u={},f,l,p){let h;const d=A({actions:{}},u),y={deep:!0};let b,_,$,O=new Set,C=new Set;const F=f.state.value[c];let J;function k(t){let e;b=_=!1,"function"==typeof t?(t(f.state.value[c]),e={type:S.patchFunction,storeId:c,events:$}):(I(f.state.value[c],t),e={type:S.patchObject,payload:t,storeId:c,events:$});const n=J=Symbol();a().then((()=>{J===n&&(b=!0)})),_=!0,w(O,e,f.state.value[c])}p||F||(f.state.value[c]={});const K=p?function(){const{state:t}=u,e=t?t():{};this.$patch((t=>{A(t,e)}))}:m;const N=(t,e="")=>{if(P in t)return t[x]=e,t;const n=function(){v(f);const e=Array.from(arguments),s=new Set,o=new Set;let a;w(C,{args:e,name:n[x],store:V,after:function(t){s.add(t)},onError:function(t){o.add(t)}});try{a=t.apply(this&&this.$id===c?this:V,e)}catch(r){throw w(o,r),r}return a instanceof Promise?a.then((t=>(w(s,t),t))).catch((t=>(w(o,t),Promise.reject(t)))):(w(s,a),a)};return n[P]=!0,n[x]=e,n},U={_p:f,$id:c,$onAction:g.bind(null,C),$patch:k,$reset:K,$subscribe(t,e={}){const n=g(O,t,e.detached,(()=>s())),s=h.run((()=>i((()=>f.state.value[c]),(n=>{("sync"===e.flush?_:b)&&t({storeId:c,type:S.direct,events:$},n)}),A({},y,e))));return n},$dispose:function(){h.stop(),O.clear(),C.clear(),f._s.delete(c)}},V=t(U);f._s.set(c,V);const W=(f._a&&f._a.runWithContext||E)((()=>f._e.run((()=>(h=e()).run((()=>r({action:N})))))));for(const t in W){const e=W[t];if(n(e)&&(!n(Y=e)||!Y.effect)||s(e))p||(!F||j(X=e)&&Object.prototype.hasOwnProperty.call(X,M)||(n(e)?e.value=F[t]:I(e,F[t])),f.state.value[c][t]=e);else if("function"==typeof e){const n=N(e,t);W[t]=n,d.actions[t]=e}}var X,Y;return A(V,W),A(o(V),W),Object.defineProperty(V,"$state",{get:()=>f.state.value[c],set:t=>{k((e=>{A(e,t)}))}}),f._p.forEach((t=>{A(V,h.run((()=>t({store:V,app:f._a,pinia:f,options:d}))))})),F&&p&&u.hydrate&&u.hydrate(V.$state,F),b=!0,_=!0,V}
/*! #__NO_SIDE_EFFECTS__ */function F(t,e,n){let s;const o="function"==typeof e;function a(n,a){const i=y();(n=n||(i?d(_,null):null))&&v(n),(n=b)._s.has(t)||(o?C(t,e,s,n):function(t,e,n){const{state:s,actions:o,getters:a}=e,i=n.state.value[t];let f;f=C(t,(function(){i||(n.state.value[t]=s?s():{});const e=c(n.state.value[t]);return A(e,o,Object.keys(a||{}).reduce(((e,s)=>(e[s]=r(u((()=>{v(n);const e=n._s.get(t);return a[s].call(e,e)}))),e)),{}))}),e,n,0,!0)}(t,s,n));return n._s.get(t)}return s=o?n:e,a.$id=t,a}function J(t){const e=o(t),a={};for(const o in e){const c=e[o];c.effect?a[o]=u({get:()=>t[o],set(e){t[o]=e}}):(n(c)||s(c))&&(a[o]=f(t,o))}return a}export{O as c,F as d,J as s};
